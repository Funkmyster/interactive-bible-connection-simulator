"use client";

import React, { useEffect, useRef } from 'react';
import * as d3 from 'd3';

function ChordDiagram({
    data,
    width,
    height,
    onNodeSelect,
    onNodeHoverStart, // New prop
    onNodeHoverEnd    // New prop
}) {
  const svgRef = useRef();

  useEffect(() => {
    // --- Initial Checks & Cleanup ---
    const svg = d3.select(svgRef.current);
    svg.selectAll("*").remove(); // Clear previous render first

    if (!data || !data.nodes || !data.links || data.nodes.length === 0 || width <= 0 || height <= 0) {
        console.log("ChordDiagram: No data or invalid dimensions/data.nodes length. Skipping render.");
        svg.append("text")
           .attr("x", width / 2).attr("y", height / 2).attr("text-anchor", "middle")
           .attr("class", "text-sm text-gray-500 dark:text-gray-400")
           .text("No connection data to display for this selection.");
      return; // Exit if data is missing, empty, or dimensions are invalid
    }
     // console.log(`ChordDiagram: Rendering with ${data.nodes.length} nodes, ${data.links.length} links.`);


    // --- D3 Setup ---
    const outerRadius = Math.min(width, height) * 0.5 - 40; // Adjusted padding slightly
    const innerRadius = outerRadius - 15; // Slightly thicker arcs

    // --- Data Processing ---
    // Nodes are assumed to be pre-sorted canonically by dataService
    const nodes = data.nodes;
    const nodeMap = new Map();
    nodes.forEach((node, i) => {
        nodeMap.set(node.id, { index: i, ...node }); // Index respects the pre-sorted order
    });
    const numNodes = nodes.length;

    // Create the matrix based on the (now canonically sorted) node order
    const matrix = Array.from({ length: numNodes }, () => Array(numNodes).fill(0));
    let validLinksProcessed = 0;
    data.links.forEach(link => {
      const sourceNodeInfo = nodeMap.get(link.source);
      const targetNodeInfo = nodeMap.get(link.target);
      // MVP v3.0: Assume value is already 1 (or use 1 regardless) for uniform thickness
      const value = 1; // Ignore link.value, use constant thickness

      if (sourceNodeInfo !== undefined && targetNodeInfo !== undefined) {
        matrix[sourceNodeInfo.index][targetNodeInfo.index] += value;
        // matrix[targetNodeInfo.index][sourceNodeInfo.index] += value; // Symmetric if needed
        validLinksProcessed++;
      }
    });
     // console.log(`ChordDiagram: Processed ${validLinksProcessed} links into matrix (value=1).`);


    // --- D3 Layouts & Scales ---
    const chord = d3.chord()
      .padAngle(numNodes > 50 ? 0.02 : 0.04) // Reduce padding slightly for many nodes
      .sortSubgroups(null) // ** MVP v3.0: Respect incoming node order for arcs **
      .sortChords(d3.descending); // Sort chords by size (optional, based on count if value=1)

    const arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);
    const ribbon = d3.ribbon().radius(innerRadius);

    // Color scale based on 'book' property (ensure consistent normalization)
    const bookNames = Array.from(new Set(nodes.map(d => d.book || 'Unknown')));
    // Using a potentially more distinct color scheme if many books are present
    const color = d3.scaleOrdinal(bookNames.length > 10 ? d3.schemeSpectral[Math.min(bookNames.length, 11)] : d3.schemeCategory10)
                    .domain(bookNames);

    // --- D3 Rendering ---
    const svgGroup = svg.append("g")
      .attr("transform", `translate(${width / 2},${height / 2})`) // Center the diagram
       // Add font styling to the group for labels
      .style("font-size", "10px")
      .style("font-family", "sans-serif")
      .datum(chord(matrix)); // Provide the layout data

    // Arcs (Groups)
    const group = svgGroup.append("g")
      .attr("class", "arcs")
      .selectAll("g")
      .data(d => d.groups) // Bind group data generated by chord(matrix)
      .join("g")
      .attr("cursor", "pointer"); // Indicate arcs are clickable

    const arcPaths = group.append("path")
      .attr("class", "arc")
      .style("fill", d => color(nodes[d.index]?.book || 'Unknown'))
      // Use slightly darker stroke for better definition
      .style("stroke", d => d3.rgb(color(nodes[d.index]?.book || 'Unknown')).darker(0.7))
      .style("stroke-width", 0.5)
      .attr("d", arc)
      .style("opacity", 1); // Initial opacity

     // Click handler remains the same
     arcPaths.on("click", (event, d) => {
          if (onNodeSelect && nodes[d.index]) {
              onNodeSelect(nodes[d.index].id);
          }
          event.stopPropagation();
      });

     // Tooltip for Arcs
     arcPaths.append("title") // Basic tooltip
       // Show aggregated value (count of connections if value=1)
       .text(d => `${nodes[d.index]?.label}\nConnections: ${d.value}`); // Use derived label

    // Ribbons (Chords)
    const ribbons = svgGroup.append("g")
      .attr("class", "ribbons")
      .attr("fill-opacity", 0.65) // Slightly adjust opacity
      .selectAll("path")
      .data(d => d) // Chord data is datum of svgGroup
      .join("path")
      .attr("class", "ribbon")
      .attr("d", ribbon)
      .style("fill", d => color(nodes[d.target.index]?.book || 'Unknown')) // Color based on target
      .style("stroke", "#fff") // White stroke for better separation
      .style("stroke-width", 0.5)
      .style("opacity", 1); // Use CSS or transitions for hover opacity

      // Tooltip for Ribbons (Value will likely always be 1 here)
      ribbons.append("title") // Basic tooltip
       .text(d => `${nodes[d.source.index]?.label} â†’ ${nodes[d.target.index]?.label}`);


    // --- Hover Effects ---
    const hoverTransitionDuration = 100; // Faster transition

    group // Add hover listeners to the group containing the arc path
      .on("mouseover", (event, d) => {
        // Call hover start callback
        if (onNodeHoverStart && nodes[d.index]) {
            onNodeHoverStart(nodes[d.index].id);
        }
        // Visual Highlighting
        svgGroup.selectAll(".ribbon") // Select ribbons within the main group
          .transition("groupHoverFadeRibbon").duration(hoverTransitionDuration)
          // Fade ribbons not connected to the hovered arc index (d.index)
          .style("opacity", ribbonData => (ribbonData.source.index === d.index || ribbonData.target.index === d.index) ? 0.9 : 0.1);

        svgGroup.selectAll(".arcs g path") // Target the arc paths
           .filter(arcData => arcData.index !== d.index) // Select arcs that are NOT the hovered one
           .transition("groupHoverFadeArc").duration(hoverTransitionDuration)
           .style("opacity", 0.3); // Fade them
        // Optionally highlight the hovered arc path itself
         d3.select(event.currentTarget).select('path.arc')
             .transition("groupHoverHighlightArc").duration(hoverTransitionDuration)
             .style("stroke-width", 1.5); // Example: make stroke thicker
      })
      .on("mouseout", (event, d) => {
         // Call hover end callback
         if (onNodeHoverEnd) {
            onNodeHoverEnd();
         }
        // Restore opacity and styles
        svgGroup.selectAll(".ribbon")
            .transition("groupHoverEnd").duration(hoverTransitionDuration)
            .style("opacity", 1); // Restore ribbon opacity (group opacity applies)
        svgGroup.selectAll(".arcs g path")
            .transition("groupHoverEnd").duration(hoverTransitionDuration)
            .style("opacity", 1) // Restore arc opacity
            .style("stroke-width", 0.5); // Restore stroke width
      });

    // --- Optional: Ribbon Hover Effects ---
    // Consider if these are needed/performant/usable
    ribbons
        .on("mouseover", (event, d) => {
            // Optionally call hover start for source/target? Might be too noisy.
            svgGroup.selectAll(".ribbon").filter(r => r !== d)
                .transition("ribbonHover").duration(hoverTransitionDuration)
                .style("opacity", 0.1);
             d3.select(event.currentTarget)
                .transition("ribbonHover").duration(hoverTransitionDuration)
                .style("opacity", 0.9);
            svgGroup.selectAll(".arcs g path")
                .filter(a => a.index !== d.source.index && a.index !== d.target.index)
                .transition("ribbonHover").duration(hoverTransitionDuration)
                .style("opacity", 0.3);
        })
        .on("mouseout", (event, d) => {
            // if (onNodeHoverEnd) onNodeHoverEnd(); // Reset hover state
            svgGroup.selectAll(".ribbon")
                .transition("ribbonHoverEnd").duration(hoverTransitionDuration)
                .style("opacity", 1);
            svgGroup.selectAll(".arcs g path")
                .transition("ribbonHoverEnd").duration(hoverTransitionDuration)
                .style("opacity", 1);
        });

    // --- Optional: Arc Labels ---
    // Adjust threshold and radius as needed for clarity/performance
    const labelRadius = outerRadius + 5;
    const totalMatrixSum = d3.sum(matrix.flat()); // Calculate total value for percentage filter
    group.append("text")
        .each(d => {
             d.angle = (d.startAngle + d.endAngle) / 2;
             d.nodeData = nodes[d.index]; // Attach node data for easy access
        })
         // Filter to show labels only for arcs with substantial value (connection count)
         // Adjust threshold (e.g., 0.005 means > 0.5%) as needed
        .filter(d => d.value > (totalMatrixSum * 0.005) && d.value > 1)
        .attr("dy", ".35em")
        .attr("class", "arc-label fill-current text-gray-700 dark:text-gray-300 text-[8px] sm:text-[10px]")
        .attr("transform", d => `
            rotate(${(d.angle * 180 / Math.PI - 90)})
            translate(${labelRadius})
            ${d.angle > Math.PI ? "rotate(180)" : ""}
        `)
        .style("text-anchor", d => d.angle > Math.PI ? "end" : "start")
        .text(d => d.nodeData?.label);


  }, [data, width, height, onNodeSelect, onNodeHoverStart, onNodeHoverEnd]); // Effect dependencies

  return (
    <svg ref={svgRef} width={width} height={height} className="chord-diagram max-w-full max-h-full"></svg>
  );
}

export default ChordDiagram;