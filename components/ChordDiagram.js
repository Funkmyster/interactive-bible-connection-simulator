"use client";

import React, { useEffect, useRef } from 'react';
import * as d3 from 'd3';

function ChordDiagram({ data, width, height, onNodeSelect }) {
  const svgRef = useRef();

  useEffect(() => {
    // --- Initial Checks & Cleanup ---
    const svg = d3.select(svgRef.current);
    svg.selectAll("*").remove(); // Clear previous render first

    if (!data || !data.nodes || !data.links || data.nodes.length === 0 || width <= 0 || height <= 0) {
        console.log("ChordDiagram: No data or invalid dimensions/data.nodes length. Skipping render.");
        // Optionally render a placeholder message inside the SVG
        svg.append("text")
            .attr("x", width / 2)
            .attr("y", height / 2)
            .attr("text-anchor", "middle")
            .attr("fill", "currentColor") // Inherit color
            .attr("class", "text-gray-500 dark:text-gray-400")
            .text("No connection data to display for this selection.");
      return; // Exit if data is missing, empty, or dimensions are invalid
    }
     console.log(`ChordDiagram: Rendering with ${data.nodes.length} nodes, ${data.links.length} links.`);


    // --- D3 Setup ---
    const outerRadius = Math.min(width, height) * 0.5 - 40; // Adjusted padding slightly
    const innerRadius = outerRadius - 15; // Slightly thicker arcs

    // --- Data Processing ---
    // Map nodes for quick index lookup and store original data
    const nodeMap = new Map();
    // Use the presorted nodes array directly from props
    const nodes = data.nodes;
    nodes.forEach((node, i) => {
        nodeMap.set(node.id, { index: i, ...node }); // Use index from the already sorted array
    });
    const numNodes = nodes.length;

    // Create the matrix based on the (now canonically sorted) node order
    const matrix = Array.from({ length: numNodes }, () => Array(numNodes).fill(0));
    let validLinksProcessed = 0;
    data.links.forEach(link => {
      const sourceNodeInfo = nodeMap.get(link.source);
      const targetNodeInfo = nodeMap.get(link.target);
      const value = link.value || 1;

      if (sourceNodeInfo !== undefined && targetNodeInfo !== undefined) {
        matrix[sourceNodeInfo.index][targetNodeInfo.index] += value;
        // Consider if symmetry is needed based on data meaning
        // matrix[targetNodeInfo.index][sourceNodeInfo.index] += value;
        validLinksProcessed++;
      }
    });
    // console.log(`ChordDiagram: Processed ${validLinksProcessed} valid links into matrix.`);


    // --- D3 Layouts & Scales ---
    const chord = d3.chord()
      .padAngle(numNodes > 50 ? 0.02 : 0.04) // Reduce padding slightly for many nodes
      .sortSubgroups(null) // ** MVP v2.0 Change: Respect incoming node order **
      .sortChords(d3.descending); // Sort chords by value (optional)

    const arc = d3.arc()
      .innerRadius(innerRadius)
      .outerRadius(outerRadius);

    const ribbon = d3.ribbon()
      // Adjust ribbon radius if needed, innerRadius is common
      .radius(innerRadius);

    // Color scale based on 'book' property (ensure consistent normalization)
    const bookNames = Array.from(new Set(nodes.map(d => d.book || 'Unknown')));
    // Using a potentially more distinct color scheme if many books are present
    const color = d3.scaleOrdinal(bookNames.length > 10 ? d3.schemeSpectral[Math.min(bookNames.length, 11)] : d3.schemeCategory10)
                    .domain(bookNames);

    // --- D3 Rendering ---
    const svgGroup = svg
      .append("g")
      .attr("transform", `translate(${width / 2},${height / 2})`) // Center the diagram
       // Add font styling to the group for labels
      .style("font-size", "10px")
      .style("font-family", "sans-serif")
      .datum(chord(matrix)); // Provide the layout data

    // Arcs (Groups)
    const group = svgGroup.append("g")
      .attr("class", "arcs")
      .selectAll("g")
      .data(d => d.groups) // Bind group data generated by chord(matrix)
      .join("g")
      .attr("cursor", "pointer");

    const arcPaths = group.append("path")
      .attr("class", "arc")
      .style("fill", d => color(nodes[d.index]?.book || 'Unknown'))
      // Use slightly darker stroke for better definition
      .style("stroke", d => d3.rgb(color(nodes[d.index]?.book || 'Unknown')).darker(0.7))
      .style("stroke-width", 0.5)
      .attr("d", arc)
      .style("opacity", 1) // Initial opacity
      .on("click", (event, d) => {
          if (onNodeSelect && nodes[d.index]) {
              onNodeSelect(nodes[d.index].id);
          }
          event.stopPropagation();
      });

     // Tooltip for Arcs
     arcPaths.append("title")
       .text(d => `${nodes[d.index]?.label}\nTotal connections value: ${d.value.toFixed(1)}`);

    // Ribbons (Chords)
    const ribbons = svgGroup.append("g")
      .attr("class", "ribbons")
      .attr("fill-opacity", 0.65) // Slightly adjust opacity
      .selectAll("path")
      .data(d => d) // Chord data is datum of svgGroup
      .join("path")
      .attr("class", "ribbon")
      .attr("d", ribbon)
      .style("fill", d => color(nodes[d.target.index]?.book || 'Unknown')) // Color based on target
      .style("stroke", "#fff") // White stroke for better separation
      .style("stroke-width", 0.5)
      .style("opacity", 1);

      // Tooltip for Ribbons
      ribbons.append("title")
       .text(d => `${nodes[d.source.index]?.label} â†’ ${nodes[d.target.index]?.label}\nConnection Value: ${d.source.value.toFixed(1)}`);

    // --- Hover Effects ---
    // Performance Note: These transitions can be costly with many elements. Simplify if needed.
    const hoverTransitionDuration = 100; // Faster transition

    group
      .on("mouseover", (event, d) => {
        // Fade unrelated elements
        ribbons.filter(ribbonData => ribbonData.source.index !== d.index && ribbonData.target.index !== d.index)
          .transition("groupHoverFadeRibbon").duration(hoverTransitionDuration)
          .style("opacity", 0.1);
        arcPaths.filter(arcData => arcData.index !== d.index)
           .transition("groupHoverFadeArc").duration(hoverTransitionDuration)
           .style("opacity", 0.3);
         // Highlight related ribbons
         ribbons.filter(ribbonData => ribbonData.source.index === d.index || ribbonData.target.index === d.index)
             .transition("groupHoverHighlightRibbon").duration(hoverTransitionDuration)
             .style("opacity", 0.9); // Make related ribbons more prominent
      })
      .on("mouseout", (event, d) => {
        // Restore opacity
        ribbons.transition("groupHoverEnd").duration(hoverTransitionDuration).style("opacity", 1); // Rely on group opacity (0.65)
        arcPaths.transition("groupHoverEnd").duration(hoverTransitionDuration).style("opacity", 1);
      });

     // Consider removing ribbon hover if performance is an issue or usability is poor
    ribbons
        .on("mouseover", (event, d) => {
            ribbons.filter(r => r !== d)
                .transition("ribbonHover").duration(hoverTransitionDuration)
                .style("opacity", 0.1);
             d3.select(event.currentTarget)
                .transition("ribbonHover").duration(hoverTransitionDuration)
                .style("opacity", 0.9);
            arcPaths
                .filter(a => a.index !== d.source.index && a.index !== d.target.index)
                .transition("ribbonHover").duration(hoverTransitionDuration)
                .style("opacity", 0.3);
        })
        .on("mouseout", (event, d) => {
            ribbons.transition("ribbonHoverEnd").duration(hoverTransitionDuration).style("opacity", 1); // Rely on group opacity (0.65)
            arcPaths.transition("ribbonHoverEnd").duration(hoverTransitionDuration).style("opacity", 1);
        });

     // --- Optional: Arc Labels (May need adjustment based on radius/font size) ---
    // Performance Note: Rendering many labels can be slow. Consider only showing labels for larger arcs.
    const labelRadius = outerRadius + 5; // Position labels just outside arcs
    group.append("text")
        .each(d => {
             d.angle = (d.startAngle + d.endAngle) / 2;
             // Store node data on the datum for easier access in transform
             d.nodeData = nodes[d.index];
        })
         // Only add labels for arcs representing a significant portion (e.g., > 1% of total)
         // or based on absolute value if preferred. Adjust threshold as needed.
        .filter(d => d.value > (d3.sum(matrix.flat()) * 0.005)) // Example filter: > 0.5% of total value
        .attr("dy", ".35em")
        .attr("class", "arc-label fill-current text-gray-700 dark:text-gray-300") // Use Tailwind color via fill-current
        .attr("transform", d => `
            rotate(${(d.angle * 180 / Math.PI - 90)})
            translate(${labelRadius})
            ${d.angle > Math.PI ? "rotate(180)" : ""}
        `)
        .style("text-anchor", d => d.angle > Math.PI ? "end" : "start")
        .text(d => d.nodeData?.label); // Use label from node data


  }, [data, width, height, onNodeSelect]); // Effect dependencies

  return (
    <svg ref={svgRef} width={width} height={height} className="chord-diagram max-w-full max-h-full"></svg>
  );
}

export default ChordDiagram;